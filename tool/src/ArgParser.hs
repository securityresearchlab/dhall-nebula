module ArgParser (opts, Options (..), Command (..)) where

import Options.Applicative

data Options = Options
  { dhallDir :: String,
    configFileName :: String,
    optCommand :: Command
  }
  deriving (Show)

data Command
  = GenerateConfig
      {configsPath :: String}
  | GenerateCertificates
      { configsPath :: String,
        caCrtPath :: String,
        caKeyPath :: String,
        nebulaCertPath :: String
      }
  | SignKey
      { keyPath :: String,
        hostName :: String,
        caCrtPath :: String,
        caKeyPath :: String,
        nebulaCertPath :: String
      }
  | AutoSignKey
      { keysDir :: String,
        keysExt :: String,
        caCrtPath :: String,
        caKeyPath :: String,
        nebulaCertPath :: String
      }
  | VerifyCert
      { crtPath :: String,
        caCrtPath :: String,
        nebulaCertPath :: String
      }
  deriving (Show)

signInput :: ParserInfo Command
signInput = info signCommand (fullDesc <> progDesc "Sign an already existing key in the keyPath")
  where
    signCommand =
      SignKey
        <$> strOption
          ( long "keyPath"
              <> help "The path of the key to sign"
          )
        <*> strOption
          ( long "hostName"
              <> help "The name of the host that will use the generated certificate"
          )
        <*> strOption
          ( long "caCrtPath"
              <> help "The path of the certificate of the CA to be used to sign"
          )
        <*> strOption
          ( long "caKeyPath"
              <> help "The path of the key of the CA to be used to sign"
          )
        <*> strOption
          ( long "nebulaCertPath"
              <> help "The path of nebula-cert executable"
          )

autoSignInput :: ParserInfo Command
autoSignInput = info autoSignCommand (fullDesc <> progDesc "Sign already existing keys, organized in a directory as if they had been generated by this tool")
  where
    autoSignCommand =
      AutoSignKey
        <$> strOption
          ( long "keysDir"
              <> help "The base dir where all the keys are; assumes the name of the file is the name of the host"
          )
        <*> strOption
          ( long "keysExt"
              <> help "The extensions of the public key files"
          )
        <*> strOption
          ( long "caCrtPath"
              <> help "The path of the certificate of the CA to be used to sign"
          )
        <*> strOption
          ( long "caKeyPath"
              <> help "The path of the key of the CA to be used to sign"
          )
        <*> strOption
          ( long "nebulaCertPath"
              <> help "The path of nebula-cert executable"
          )

generateCertificates :: ParserInfo Command
generateCertificates = info generateCrtCommand (fullDesc <> progDesc "Generate keys and certificates for each host")
  where
    generateCrtCommand =
      GenerateCertificates
        <$> strOption
          ( long "configsPath"
              <> help "The base directory where to put the generated keys and certificates"
          )
        <*> strOption
          ( long "caCrtPath"
              <> help "The path of the certificate of the CA to be used to sign"
          )
        <*> strOption
          ( long "caKeyPath"
              <> help "The path of the key of the CA to be used to sign"
          )
        <*> strOption
          ( long "nebulaCertPath"
              <> help "The path of nebula-cert executable"
          )

generateConfig :: ParserInfo Command
generateConfig = info generateConfigCommand (fullDesc <> progDesc "Generate yaml configuration for each host")
  where
    generateConfigCommand =
      GenerateConfig
        <$> strOption
          ( long "configsPath"
              <> help "The base directory where to put the generated yaml files"
          )

verifyCert :: ParserInfo Command
verifyCert = info signCommand (fullDesc <> progDesc "Verify that the certificate is valid and compatible with the network configuration")
  where
    signCommand =
      VerifyCert
        <$> strOption
          ( long "crtPath"
              <> help "The path of the certificate to check"
          )
        <*> strOption
          ( long "caCrtPath"
              <> help "The path of the certificate of the CA to be used to sign"
          )
        <*> strOption
          ( long "nebulaCertPath"
              <> help "The path of nebula-cert executable"
          )

-- commandParser :: Parser Command
commandParser =
  hsubparser
    ( command "config" generateConfig
        <> command "certificates" generateCertificates
        <> command "sign" signInput
        <> command "autosign" autoSignInput
        <> command "verify" verifyCert
    )

-- dhallDirParser :: Parser Options
dhallDirParser =
  Options
    <$> strOption
      (long "dhallDir"
        <> help "The directory of the Dhall configuration")
    <*> strOption
      (long "configFileName"
        <> help "The name of the file containing the Dhall configuration, without extension")

opts :: ParserInfo Options
-- opts = info (signInput <|> generateConfig <|> generateCertificates) (fullDesc <> progDesc "Generate configuration for Nebula")
opts = info ((dhallDirParser <*> commandParser) <**> helper) (fullDesc <> progDesc "Generate configuration for Nebula")
